isinstance - проверяет принадлежность объекта к классу
isinstance(5, int) == True

__dict__ - получает все ЛОКАЛЬНЫЕ атрибуты объекта
Car.__dict__

getattr - получает значение атрибута класса
getattr(Car, 'model')

setattr - задает значение атрибуту класса
setattr(Car, 'model', 'BMV')


монотосостояние:
class Cat:
    __shared_attr = {
        'breed': 'pers',
        'color': 'black',
    }

    def method(self):
        self.__dict__ = Cat.__shared_attr


property, getter-method, setter-method
@property - декоратор, который позволяет создавать свойства класса, которые автоматически
генерируются при вызове. Свойство может быть только для чтения или можно добавить метод для
установки значения.
property - эта функция позволяет вам превращать атрибуты класса в свойства или
управляемые атрибуты. Обычно property называют встроенной функцией. Однако property -
это класс, предназначенный для работы как функция, а не как обычный класс

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    def get_balance(self):
        return self.__balance

    def set_balance(self, value):
        if not isinstance(value, (int, float)):
            raise ValueError('Баланс должен быть числом')
        self.__balance = value

    def del_balance(self):
        del self.__balance

    balance = property(fget=get_balance, fset=set_balance, fdel=del_balance)

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    @property
    def my_balance(self):
        return self.__balance

    @my_balance.setter
    def my_balance(self, value):
        if not isinstance(value, (int, float)):
            raise ValueError('Баланс должен быть числом')
        self.__balance = value

    @my_balance.deleter
    def my_balance(self):
        del self.__balance

#Вычисляемые property
class Square:
    def __init__(self, s):
        self.__side = s
        self.__area = None

    @property
    def side(self):
        return self.__side

    @side.setter
    def side(self, value):
        self.__side = value
        self.__area = None

    @property
    def area(self):
        if self.__area == None:
            self.__area = self.__side ** 2
        return self.__area


#classmethod, staticmethod
@staticmethod - декоратор, который используется для создания статистического метода в классе.
Статистический метод не требует создания экземпляра класса, чтобы использоваться,
и может использоваться напрямую через имя класса.
@classmethod - декоратор, который используется для создания метода класса, который имеет доступ
к классу и его атрибутам. Как и статический метод, классовый метод может быть вызван напрямую
через имя класса.
class Example:
    def hello():
        print('hello')

    def isinstance_hello(self):
        print(f'isinstance_hello {self}')

    @staticmethod
    def static_hello():
        print('static_hello')

    @classmethod
    def class_hello(cls):
        print(f'class_hello {cls}')

Example.static_hello()
Example.class_hello()
a = Example()
a.static_hello()
a.class_hello()


#Магические методы __str__ и __repr__
__str__ - отображение для пользователя(если нет __repr__, перекроет везде кроме вызова экземляра класса напрямую)
__repr__ - отображение для разработчика(если нет __str_, перекроет его везде)
w = Lion()
w __repr__
print(w) __str__
str(w) __str__

#Магические методы __len__ и __abs__
__len__ - вычисляет длину, не поддерживает отрицательные значения на выходе
__abs__ - вычисляет значение по модулю

#Магические методы арифметики
__add__() – для операции сложения
__sub__() – для операции вычитания
__mul__() – для операции умножения
__truediv__() – для операции деления

#Магические методы сравнения
__eq__ - отвечает за ==
__ne__ - отвечает за !=
__lt__ - отвечает за <
__le__ - отвечает за <=
__gt__ - отвечает за >
__ge__ - отвечает за >=
__eq__ и __hash__ раньше считывали значения по id, теперь при объявлении __eq__ слетает __hash__
class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return isinstance(other, Point) and self.x == other.x and self.y == self.y

    def __hash__(self):
        return hash((self.x, self.y))


Чтобы не реализовывать все магические методы сравнения, можно использовать декоратор
functools.total_ordering, который позволяет сократить код, реализовав только методы __eq__, __lt__
from functools import total_ordering

@total_ordering
class Account:

    def __init__(self, balance):
        self.balance = balance

    def __eq__(self, other):
        return self.balance == other.balance

    def __lt__(self, other):
        return self.balance < other.balance


acc1 = Account(10)
acc2 = Account(20)
print(acc1 > acc2)
print(acc1 < acc2)
print(acc1 == acc2)
print(acc1 != acc2)
print(acc1 >= acc2)
print(acc1 <= acc2)


#Магический метод __call__
Реализация метода __call__ нужна, когда мы хотим, чтобы экземпляры класса вели себя как функции.
А поскольку метод __call__ делает экземпляр вызываемым, мы можем использовать его в качестве декоратора.
class Storage:

    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print('Подключение к хранилищу')
        self.func()
        print('Отключение от хранилища')


@Storage
def upload_file():
    print('Загрузка файла..')


upload_file()


#Полиморфизм
Одна и та же сущность (операция, функция, объект, метод) может использоваться для разных типов.


# Магические методы __getitem__, __setitem__, __delitem__ для индексации
class Vector:

    def __init__(self, *args):
        self.values = list(args)

    def __repr__(self):
        return str(self.values)

    def __getitem__(self, item):
        if 1 <= item <= len(self.values):
            return self.values[item - 1]
        else:
            raise IndexError('Индекс за границами нашей коллекции')

    def __setitem__(self, key, value):
        if 1 <= key <= len(self.values):
            self.values[key - 1] = value
        elif key > len(self.values):
            diff = key - len(self.values)
            self.values.extend([None] * diff)
            self.values[key - 1] = value
        else:
            raise IndexError('Индекс за границами нашей коллекции')

    def __delitem__(self, key):
        if 0 <= key <= len(self.values):
            del self.values[key]
        else:
            raise IndexError('Индекс за границами нашей коллекции')


# Магические методы __iter__, __next__
class Mark:

    def __init__(self, values):
        self.value = values
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        print('call next mark')
        if self.index >= len(self.value):
            self.index = 0
            raise StopIteration
        letter = self.value[self.index]
        self.index += 1
        return letter


class Student:

    def __init__(self, name, surname, marks):
        self.name = name
        self.surname = surname
        self.marks = marks

    def __getitem__(self, item):
        return self.marks[item]

    def __iter__(self):
        print('call iter student')
        self.index = 0
        return iter(self.marks)

    def __next__(self):
        if self.index >= len(self.surname):
            raise StopIteration
        letter = self.name[self.index]
        self.index += 1
        return letter


m = Mark([3, 3, 2, 5, 4, 1])
igor = Student('Igor', 'Ivanov', m)
for i in igor:
    print(i)


#Наследование
class A:
    pass

class B(A):
    pass

issubclass(B, A) - True



#Множественное наследование
class Doctor:

    def __init__(self, degree):
        self.degree = degree

    def graduete(self):
        print('Ура, я отучися на доктора')

    def can_build(self):
        print('Я доктор, я тоже умею строить, но плохо')


class Builder:

    def __init__(self, rank):
        self.rank = rank

    def graduete(self):
        print('Ура, я отучися на строителя')

    def can_build(self):
        print('Я строитель, я умею строить')


class Person(Builder, Doctor):

    def __init__(self, rank, degree):
        # self.rank = rank
        # self.degree = degree
        super().__init__(rank)
        Doctor.__init__(self, degree)
    def __str__(self):
        return f'Person {self.rank} {self.degree}'


s = Person(5, 'spec')
print(s)


MRO - nethod resolution order (порядок разрешения методов). Этот порядок относится не только к поискам
методов, но и к прочим атрибутам класса, так как методы - это частный случай более общего понятия "атрибут"
Class.mro()
Данная команда возвращает нам список классов ровно в том порядке, в котором Python будет искать методы в
иерархии класса пока не найдет нужный или не выдаст ошибку
def get_mro(cls):
    print(*[c.__name__ for c in cls.mro()], sep=' -> ')
Данный список можно получить при помощи функции get_mro
Когда нельзя линеаризовать?
class X:pass
class Y:pass
class A(X, Y):pass
class B(Y, X):pass
class T(A, B):pass

class X: pass
class Y(X): pass
class A(X, Y): pass

Итак, у нас на руках есть сам класс, список всех его предков и связей между ними.
Из этих данных нам нужно построить упорядоченный список классов, в которых будет производиться поиск метода слева направо.
Такой список называется линеаризацией класса.


#Магический метод __slots__
Преимущества: Ограничивает число аргументов, потребляет меньше памяти за счет отсутствия __dict__, выполняет быстрее операции с экземплярами
class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y


class PointSlots:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y


def make_cl1():
    cl1 = Point(3, 4)
    cl1.x = 100
    cl1.x
    del cl1.x


def make_cl2():
    cl2 = PointSlots(3, 4)
    cl2.x = 100
    cl2.x
    del cl2.x


print(timeit.timeit(make_cl1))
print(timeit.timeit(make_cl2))
p = Point(3, 5)
ps = PointSlots(5, 6)
print(p.__sizeof__(), p.__dict__.__sizeof__())


# Exceptions in Python
f = open('1.txt')
try:
    1 / 5
except (KeyError, IndexError):
    print(LookupError)
else:
    print('good')
finally:
    print('end')
    f.close()


# Инструкция raise
try:
    raise ValueError('ошибка значения')
except ValueError as first:
    try:
        raise TypeError('ошибка типа')
    except TypeError as second:
        raise Exception('большое исключение') from first/None