isinstance - проверяет принадлежность объекта к классу
isinstance(5, int) == True

__dict__ - получает все ЛОКАЛЬНЫЕ атрибуты объекта
Car.__dict__

getattr - получает значение атрибута класса
getattr(Car, 'model')

setattr - задает значение атрибуту класса
setattr(Car, 'model', 'BMV')


монотосостояние:
class Cat:
    __shared_attr = {
        'breed': 'pers',
        'color': 'black',
    }

    def method(self):
        self.__dict__ = Cat.__shared_attr


property, getter-method, setter-method
@property - декоратор, который позволяет создавать свойства класса, которые автоматически
генерируются при вызове. Свойство может быть только для чтения или можно добавить метод для
установки значения.
property - эта функция позволяет вам превращать атрибуты класса в свойства или
управляемые атрибуты. Обычно property называют встроенной функцией. Однако property -
это класс, предназначенный для работы как функция, а не как обычный класс

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    def get_balance(self):
        return self.__balance

    def set_balance(self, value):
        if not isinstance(value, (int, float)):
            raise ValueError('Баланс должен быть числом')
        self.__balance = value

    def del_balance(self):
        del self.__balance

    balance = property(fget=get_balance, fset=set_balance, fdel=del_balance)

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    @property
    def my_balance(self):
        return self.__balance

    @my_balance.setter
    def my_balance(self, value):
        if not isinstance(value, (int, float)):
            raise ValueError('Баланс должен быть числом')
        self.__balance = value

    @my_balance.deleter
    def my_balance(self):
        del self.__balance

#Вычисляемые property
class Square:
    def __init__(self, s):
        self.__side = s
        self.__area = None

    @property
    def side(self):
        return self.__side

    @side.setter
    def side(self, value):
        self.__side = value
        self.__area = None

    @property
    def area(self):
        if self.__area == None:
            self.__area = self.__side ** 2
        return self.__area


#classmethod, staticmethod
@staticmethod - декоратор, который используется для создания статистического метода в классе.
Статистический метод не требует создания экземпляра класса, чтобы использоваться,
и может использоваться напрямую через имя класса.
@classmethod - декоратор, который используется для создания метода класса, который имеет доступ
к классу и его атрибутам. Как и статический метод, классовый метод может быть вызван напрямую
через имя класса.
class Example:
    def hello():
        print('hello')

    def isinstance_hello(self):
        print(f'isinstance_hello {self}')

    @staticmethod
    def static_hello():
        print('static_hello')

    @classmethod
    def class_hello(cls):
        print(f'class_hello {cls}')

Example.static_hello()
Example.class_hello()
a = Example()
a.static_hello()
a.class_hello()


#Магические методы __str__ и __repr__
__str__ - отображение для пользователя(если нет __repr__, перекроет везде кроме вызова экземляра класса напрямую)
__repr__ - отображение для разработчика(если нет __str_, перекроет его везде)
w = Lion()
w __repr__
print(w) __str__
str(w) __str__

#Магические методы __len__ и __abs__
__len__ - вычисляет длину, не поддерживает отрицательные значения на выходе
__abs__ - вычисляет значение по модулю

#Магические методы арифметики
__add__() – для операции сложения
__sub__() – для операции вычитания
__mul__() – для операции умножения
__truediv__() – для операции деления

#Магические методы сравнения
__eq__ - отвечает за ==
__ne__ - отвечает за !=
__lt__ - отвечает за <
__le__ - отвечает за <=
__gt__ - отвечает за >
__ge__ - отвечает за >=
__eq__ и __hash__ раньше считывали значения по id, теперь при объявлении __eq__ слетает __hash__
class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return isinstance(other, Point) and self.x == other.x and self.y == self.y

    def __hash__(self):
        return hash((self.x, self.y))


Чтобы не реализовывать все магические методы сравнения, можно использовать декоратор
functools.total_ordering, который позволяет сократить код, реализовав только методы __eq__, __lt__
from functools import total_ordering

@total_ordering
class Account:

    def __init__(self, balance):
        self.balance = balance

    def __eq__(self, other):
        return self.balance == other.balance

    def __lt__(self, other):
        return self.balance < other.balance


acc1 = Account(10)
acc2 = Account(20)
print(acc1 > acc2)
print(acc1 < acc2)
print(acc1 == acc2)
print(acc1 != acc2)
print(acc1 >= acc2)
print(acc1 <= acc2)