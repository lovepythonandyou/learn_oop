isinstance - проверяет принадлежность объекта к классу
isinstance(5, int) == True

__dict__ - получает все ЛОКАЛЬНЫЕ атрибуты объекта
Car.__dict__

getattr - получает значение атрибута класса
getattr(Car, 'model')

setattr - задает значение атрибуту класса
setattr(Car, 'model', 'BMV')


монотосостояние:
class Cat:
    __shared_attr = {
        'breed': 'pers',
        'color': 'black',
    }

    def method(self):
        self.__dict__ = Cat.__shared_attr


property, getter-method, setter-method
@property - декоратор, который позволяет создавать свойства класса, которые автоматически
генерируются при вызове. Свойство может быть только для чтения или можно добавить метод для
установки значения.
property - эта функция позволяет вам превращать атрибуты класса в свойства или
управляемые атрибуты. Обычно property называют встроенной функцией. Однако property -
это класс, предназначенный для работы как функция, а не как обычный класс

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    def get_balance(self):
        return self.__balance

    def set_balance(self, value):
        if not isinstance(value, (int, float)):
            raise ValueError('Баланс должен быть числом')
        self.__balance = value

    def del_balance(self):
        del self.__balance

    balance = property(fget=get_balance, fset=set_balance, fdel=del_balance)

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    @property
    def my_balance(self):
        return self.__balance

    @my_balance.setter
    def my_balance(self, value):
        if not isinstance(value, (int, float)):
            raise ValueError('Баланс должен быть числом')
        self.__balance = value

    @my_balance.deleter
    def my_balance(self):
        del self.__balance

#Вычисляемые property
class Square:
    def __init__(self, s):
        self.__side = s
        self.__area = None

    @property
    def side(self):
        return self.__side

    @side.setter
    def side(self, value):
        self.__side = value
        self.__area = None

    @property
    def area(self):
        if self.__area == None:
            self.__area = self.__side ** 2
        return self.__area


#classmethod, staticmethod
@staticmethod - декоратор, который используется для создания статистического метода в классе.
Статистический метод не требует создания экземпляра класса, чтобы использоваться,
и может использоваться напрямую через имя класса.
@classmethod - декоратор, который используется для создания метода класса, который имеет доступ
к классу и его атрибутам. Как и статический метод, классовый метод может быть вызван напрямую
через имя класса.
class Example:
    def hello():
        print('hello')

    def isinstance_hello(self):
        print(f'isinstance_hello {self}')

    @staticmethod
    def static_hello():
        print('static_hello')

    @classmethod
    def class_hello(cls):
        print(f'class_hello {cls}')

Example.static_hello()
Example.class_hello()
a = Example()
a.static_hello()
a.class_hello()


#Магические методы __str__ и __repr__
__str__ - отображение для пользователя(если нет __repr__, перекроет везде кроме вызова экземляра класса напрямую)
__repr__ - отображение для разработчика(если нет __str_, перекроет его везде)
w = Lion()
w __repr__
print(w) __str__
str(w) __str__

#Магические методы __len__ и __abs__
__len__ - вычисляет длину, не поддерживает отрицательные значения на выходе
__abs__ - вычисляет значение по модулю